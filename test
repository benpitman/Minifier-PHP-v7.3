#!/bin/bash

die()
{
    printf '%s\n' "$*"
    exit 1
}

if (( ${BASH_VERSINFO[0]} < 4 )); then
    die 'Incorrect Bash version. Requires 4.3 or later'
fi
if (( ${BASH_VERSINFO[0]} == 4 && ${BASH_VERSINFO[1]} < 3 )); then
    die 'Incorrect Bash version. Requires 4.3 or later'
fi

showHelp()
{
    # Display horizontal line
    cat << ____HELP
Usage: $0 [-h] [-g] [-r FILE] [-x] ...

        -h      displays this help text and exits

        -u      uninstalls the game

        -r FILE
                runs in replay mode

        -x      runs in debug mode
                all output it sent to /var/games/tetris/debug.log

NOTES:
        replay files are stored in /var/games/tetris/replays

Copyright © Ben Pitman
____HELP
    exit 0
}

installTetris()
{
    local password

    if [[ "$UID" != "0" ]]; then
        printf "Your password is required to install this game.
                \rLeave blank to cancel install.
                \rRun as root if you don't have a password.\n"
        while true; do
            IFS= read -sp '> ' password
            [ -z "$password" ] && exit 0
            if $( echo "$password" | sudo -Svp '' ); then
                break
            fi
        done
        sudo mkdir -p "$REPLAY_DIR" 2>/dev/null
        sudo chmod -R o+wr "$LOG_DIR"
    else
        mkdir -p "$REPLAY_DIR" 2>/dev/null
        chmod -R o+wr "$LOG_DIR"
    fi
}

uninstallTetris()
{
    local password

    if [[ "$UID" != "0" ]]; then
        sudo -k
        printf 'Your password is required to uninstall this game.
                \rLeave blank to cancel uninstall.'
        while read -rsp $'\n> ' password; do
            [ -z "$password" ] && exit 0
            if { echo "$password" | sudo -Svp ''; } 2>/dev/null; then
                break
            else
                printf 'Error: Invalid Password'
            fi
        done
        sudo rm -rf /var/games/tetris
        sudo rm -f /usr/local/bin/tetris
    else
        rm -rf /var/games/tetris
        rm -f /usr/local/bin/tetris
    fi

    printf 'uninstallation complete\n'
    exit 0
}

checkTerminalSize()
{
    local               \
        boxWidth        \
        maxWidth=41     \
        maxHeight=23    \
        termWidth       \
        x               \
        y

    (( $( tput cols ) > $maxWidth && $( tput lines ) > $maxHeight )) && return

    tput civis
    stty -echo
    printf '%s\n' 'Your terminal is not large enough' 'Please resize the window manually to fit the following grid'
    read -rsp "Press enter to continue, and again to refresh or finish"

    until (( $( tput cols ) > $maxWidth && $( tput lines ) > $maxHeight )); do
        (( termWidth = ($( tput cols ) - 1) ))
        (( boxWidth = ($maxWidth > $termWidth ? $termWidth : $maxWidth) ))
        printf '\e[2J\e[1;1H'

        for (( y = 0; $y <= $maxHeight; y++ )); do
            for (( x = 0; $x <= $boxWidth; x++ )); do
                if (( $y == 0 )); then
                    if (( $x == 0 )); then
                        printf '\u250c' # ┌
                    elif (( $x == ($maxWidth / 2) )); then
                        printf '\u252c' # ┬
                    elif (( $x == $maxWidth )); then
                        printf '\u2510' # ┐
                    else
                        printf '\u2500' # ─
                    fi
                elif (( $y == ($maxHeight / 2) )); then
                    if (( $x == 0 )); then
                        printf '\u251c' # ├
                    elif (( $x == ($maxWidth / 2) )); then
                        printf '\u253c' # ┼
                    elif (( $x == $maxWidth )); then
                        printf '\u2524' # ┤
                    else
                        printf '\u2500' # ─
                    fi
                elif (( $y == $maxHeight )); then
                    if (( $x == 0 )); then
                        printf '\u2514' # └
                    elif (( $x == ($maxWidth / 2) )); then
                        printf '\u2534' # ┴
                    elif (( $x == $maxWidth )); then
                        printf '\u2518' # ┘
                    else
                        printf '\u2500' # ─
                    fi
                elif (( $x == 0 || $x == ($maxWidth / 2) || $x == $maxWidth )); then
                    printf '\u2502' # │
                else
                    printf ' '
                fi
            done
            (( $y != $maxHeight )) && echo
        done
        read
    done
    tput cvvis
    stty echo
}

intrap()
{
    tput cvvis
    printf '\e[24;1H\e[0m\n'
    exit 0
}
trap intrap INT
trap 'stty sane' EXIT

checkTerminalSize

declare -g _alertTimeout=0
declare -g _colourMode=
declare -g _currentPiece=
declare -g _debug=false
declare -g _gameMode='NORMAL'
declare -g _ghosting='INACTIVE'
declare -g _ghostingIsSet=false
declare -g _ghostY=
declare -g _inTTY=
declare -g _level=
declare -g _lines=
declare -g _logging='INACTIVE'
declare -g _loggingIsSet=false
declare -g _nextPiece=
declare -g _pieceX=
declare -g _pieceY=
declare -g _replay=false
declare -g _replayIndex=0
declare -ag _replayInputs=
declare -g _rotation=
declare -g _score=0
declare -g _state=0

declare -Ag _selected=(
    ['main']=0
    ['settings']=0
)

while getopts ":h :u :r: :x" arg; do
    case $arg in
        h)  showHelp;;
        u)  uninstallTetris;;
        r)  if test -s "$OPTARG"; then
                _replay=true
                _replayInputs=( $( fold -b1 "$OPTARG" ) )
                _state=1
            else
                die "$OPTARG is not a file"
            fi;;
        x)  _debug=true;;
        \?) die "Invalid option -$OPTARG";;
        \:) die "Option -$OPTARG requires a parameter";;
    esac
done

if test -n "$_replayFile"; then
    _replay=true
    _replayInputs=( $( fold -b1 "$_replayFile" ) )
    _state=1
fi

stty -echo  # Disable echo
tput civis  # Disable cursor blinker

# If game is loaded on a terminal outside of a GUI environment
if test -z "$DISPLAY" || [[ "$TERM" == "linux" ]]; then
    _inTTY=true
    _colourMode='SIMPLE'
else
    _inTTY=false
    _colourMode='NORMAL'
fi

################################## GENERAL #####################################

declare -rg PS4='+(${LINENO}) ${FUNCNAME[0]}(): '
declare -rg LOG_DIR='/var/games/tetris'
declare -rg REPLAY_DIR='/var/games/tetris/replays'
declare -rg HIGHSCORE_LOG="$LOG_DIR/highscores.ths"
declare -rg SETTINGS="$LOG_DIR/settings.txt"
declare -rg ERROR_LOG="$LOG_DIR/error.log"
declare -rg DEBUG_LOG="$LOG_DIR/debug.log"
declare -rg INPUT_LOG="$LOG_DIR/input.log"
declare -rg UP='A'
declare -rg DOWN='B'
declare -rg RIGHT='C'
declare -rg LEFT='D'
declare -rg CEILING=2
declare -rg FLOOR=23
declare -rg R_WALL=20
declare -rg L_WALL=2
declare -arg X_POSITIONS=({2..20..2})

if (( ${BASH_VERSINFO[0]} == 4 && ${BASH_VERSINFO[1]} < 4 )); then
    declare -rg LEGACY=true
else
    declare -rg LEGACY=false
fi

if test -s "$SETTINGS" && ! $_replay; then
    source "$SETTINGS"
fi
touch "$HIGHSCORE_LOG" # Create score log if doesn't exist

if $_debug; then
    # Debug mode sends STDERR to an error file
    exec 2>"$DEBUG_LOG"
    set -xT
else
    exec 2>"$ERROR_LOG"
fi

test -d "$REPLAY_DIR" || installTetris

################################## Screens #####################################

if ! $_inTTY; then
    declare -arg MAIN_SCREEN=(
        '┌────────────────────────────────────────┐'
        '│                                        │'
        '│  █▛██▜█ ██ ▜█ █▛██▜█ ██ █▙  ██  ▟▙ ▜█  │'
        '│  ▛ ██ ▜ ██  ▜ ▛ ██ ▜ ██ ██  ██  ▜█▙ ▜  │'
        '│    ██   ██ █    ██   ██ ▛   ██   ▜█▙   │'
        '│    ██   ██  ▟   ██   ██ ▙   ██  ▙ ▜█▙  │'
        '│    ██   ██ ▟█   ██   ██ █▙  ██  █▙ ▜▛  │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                           © Ben Pitman │'
        '└────────────────────────────────────────┘'
    )
    declare -arg FIELD_SCREEN=(
        '┌────────────────────┬───────────────────┐'
        '│                    │  ╔═════════════╗  │'
        '│                    ├──╢  S C O R E  ╟──┤'
        '│                    │  ╚═════════════╝  │'
        '│                    ╞═══════════════════╡'
        '│                    │             0     │'
        '│                    ╞═══════════════════╡'
        '│                    │                   │'
        '│                    │  ╔═════════════╗  │'
        '│                    │  ║  L E V E L  ║  │'
        '│                    │  ║          0  ║  │'
        '│                    │  ╚═════════════╝  │'
        '│                    │  ╔═════════════╗  │'
        '│                    │  ║  L I N E S  ║  │'
        '│                    │  ║          0  ║  │'
        '│                    │  ╚═════════════╝  │'
        '│                    │                   │'
        '│                    │  ╔══════════╗     │'
        '│                    │  ║          ║     │'
        '│                    │  ║          ║     │'
        '│                    │  ║          ║     │'
        '│                    │  ║          ║     │'
        '│                    │  ╚══════════╝     │'
        '└────────────────────┴───────────────────┘'
    )
    declare -arg SCORES_SCREEN=(
        '┌────────────────────────────────────────┐'
        '│            ╔═════════════╗             │'
        '├────────────╢ S C O R E S ╟─────────────┤'
        '│            ╚═════════════╝             │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '└────────────────────────────────────────┘'
    )
    declare -arg SETTINGS_SCREEN=(
        '┌────────────────────────────────────────┐'
        '│          ╔═════════════════╗           │'
        '├──────────╢ S E T T I N G S ╟───────────┤'
        '│          ╚═════════════════╝           │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                      ┌──────────────┐  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      └──────────────┘  │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '└────────────────────────────────────────┘'
    )
else
    declare -arg MAIN_SCREEN=(
        '┌────────────────────────────────────────┐'
        '│                                        │'
        '│  ██████ █████ ██████ █████  ██  █████  │'
        '│    ██   ██      ██   ██  ██ ██ ██      │'
        '│    ██   ████    ██   ████   ██   ██    │'
        '│    ██   ██      ██   ██  ██ ██     ██  │'
        '│    ██   █████   ██   ██  ██ ██ █████   │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                           © Ben Pitman │'
        '└────────────────────────────────────────┘'
    )
    declare -arg FIELD_SCREEN=(
        '┌────────────────────┬───────────────────┐'
        '│                    │  ┌─────────────┐  │'
        '│                    ├──┤  S C O R E  ├──┤'
        '│                    │  └─────────────┘  │'
        '│                    ├───────────────────┤'
        '│                    │             0     │'
        '│                    ├───────────────────┤'
        '│                    │                   │'
        '│                    │  ┌─────────────┐  │'
        '│                    │  │  L E V E L  │  │'
        '│                    │  │          0  │  │'
        '│                    │  └─────────────┘  │'
        '│                    │  ┌─────────────┐  │'
        '│                    │  │  L I N E S  │  │'
        '│                    │  │          0  │  │'
        '│                    │  └─────────────┘  │'
        '│                    │                   │'
        '│                    │  ┌──────────┐     │'
        '│                    │  │          │     │'
        '│                    │  │          │     │'
        '│                    │  │          │     │'
        '│                    │  │          │     │'
        '│                    │  └──────────┘     │'
        '└────────────────────┴───────────────────┘'
    )
    declare -arg SCORES_SCREEN=(
        '┌────────────────────────────────────────┐'
        '│            ┌─────────────┐             │'
        '├────────────┤ S C O R E S ├─────────────┤'
        '│            └─────────────┘             │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '└────────────────────────────────────────┘'
    )
    declare -arg SETTINGS_SCREEN=(
        '┌────────────────────────────────────────┐'
        '│          ┌─────────────────┐           │'
        '├──────────┤ S E T T I N G S ├───────────┤'
        '│          └─────────────────┘           │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '│                      ┌──────────────┐  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      │              │  │'
        '│                      └──────────────┘  │'
        '│                                        │'
        '│                                        │'
        '│                                        │'
        '└────────────────────────────────────────┘'
    )
fi

############################## States and Modes ################################

setColourMode()
{
    _colourMode=${COLOUR_MODES[$1]}
}

setGameMode()
{
    _gameMode=${GAME_MODES[$1]}
}

toggleGhosting()
{
    if $_ghostingIsSet; then
        _ghostingIsSet=false
        _ghosting=${GHOST_MODES[1]}
    else
        _ghostingIsSet=true
        _ghosting=${GHOST_MODES[0]}
    fi
}

toggleLogging()
{
    if $_loggingIsSet; then
        _loggingIsSet=false
        _logging=${LOG_MODES[1]}
    else
        _loggingIsSet=true
        _logging=${LOG_MODES[0]}
    fi
}

declare -Arg STATES=(
    ['MAIN']=0
    ['FIELD']=1
    ['SCORES']=2
    ['SETTINGS']=3
    ['GAME_OVER']=4
)

setState()
{
    _state=${STATES[$1]}
}

############################### Menu Navigation ################################

declare -rg START_POSITION='2,8'

declare -arg MAIN_OPTIONS=(
    'N E W   G A M E'
    'S C O R E S'
    'S E T T I N G S'
    'Q U I T'
)

declare -Arg MAIN_MENU=(
    ['MAX']=3
    ['OPTIONS']='MAIN_OPTIONS'
    ['PADDING']=' '

    ['0,Y']=11
    ['0,X']=12

    ['1,Y']=14
    ['1,X']=14

    ['2,Y']=17
    ['2,X']=12

    ['3,Y']=20
    ['3,X']=16
)

declare -arg SETTINGS_OPTIONS=(
    'COLOUR  MODE'
    'GAME  MODE'
    'GHOSTING'
    'RECORD'
    'BACK'
)

# Settings menu options
declare -Arg SETTINGS_MENU=(
    ['MAX']=4
    ['OPTIONS']='SETTINGS_OPTIONS'
    ['PADDING']=' '

    ['0,Y']=10
    ['0,X']=5

    ['1,Y']=12
    ['1,X']=6

    ['2,Y']=14
    ['2,X']=7
    ['2,NOTE']='(Can cause flicker)'

    ['3,Y']=16
    ['3,X']=8
    ['3,NOTE']='All inputs logged for playback'

    ['4,Y']=22
    ['4,X']=9
)

# Opens up the submenu for selection
declare -Arg SETTINGS_CLEAR_SUB_MENU=(
    ['MAX']=11

    ['Y']=9
    ['X']=25

     ['0']='┌────────────┐'
     ['1']='│            │'
     ['2']='│            │'
     ['3']='│            │'
     ['4']='│            │'
     ['5']='│            │'
     ['6']='│            │'
     ['7']='│            │'
     ['8']='│            │'
     ['9']='│            │'
    ['10']='└────────────┘'
)

# Clears the chosen items for repopulation
declare -Arg SETTINGS_SUB_MENU=(
    ['MAX']=3
    ['WIDTH']=11

    ['0']='_colourMode'
    ['0,Y']=10
    ['0,X']=26

    ['1']='_gameMode'
    ['1,Y']=12
    ['1,X']=26

    ['2']='_ghosting'
    ['2,Y']=14
    ['2,X']=26

    ['3']='_logging'
    ['3,Y']=16
    ['3,X']=26

    ['CLEAR']='              '
    ['CLEAR,Y']=9
    ['CLEAR,X']=25
    ['CLEAR,MAX']=11
)

declare -Arg NOTE=(
    ['CLEAR']='                                        '
    ['Y']=6
    ['X']=22
)

declare -arg COLOUR_MODES=(
    'NORMAL'
    'SIMPLE'
    'SHADOW'
    'BLEACH'
)

# Settings colour mode submenu options
declare -Arg SETTINGS_COLOUR_SUB_MENU=(
    ['MAX']=3
    ['OPTIONS']='COLOUR_MODES'
    ['PADDING']='  '

    ['0,Y']=11
    ['0,X']=27
    ['0,NOTE']="Original Tetris colours"

    ['1,Y']=13
    ['1,X']=27
    ['1,NOTE']="Reduced colours for lower colour depth"

    ['2,Y']=15
    ['2,X']=27
    ['2,NOTE']="White on black"

    ['3,Y']=17
    ['3,X']=27
    ['3,NOTE']="Black on white"
)

declare -arg GAME_MODES=(
    'NORMAL'
    'ROTATE'
    'FORGET'    # May not be implemented
)

declare -Arg SETTINGS_GAME_SUB_MENU=(
    ['MAX']=1
    ['OPTIONS']='GAME_MODES'
    ['PADDING']='  '

    ['0,Y']=11
    ['0,X']=27
    ['0,NOTE']="It's just Tetris"

    ['1,Y']=13
    ['1,X']=27
    ['1,NOTE']="Limited to 3 rotations per tetromino"

    ['2,Y']=17
    ['2,X']=27
    ['2,NOTE']="Placed tetrominoes fade out over time"
)

declare -arg GHOST_MODES=(
    'ACTIVE'
    'INACTIVE'
)

declare -arg LOG_MODES=(
    'ACTIVE'
    'INACTIVE'
)

declare -arg SCORES_OPTIONS=(
    'BACK'
)

declare -Arg SCORES_MENU=(
    ['MAX']=0
    ['OPTIONS']='SCORES_OPTIONS'
    ['PADDING']=' '

    ['0,Y']=22
    ['0,X']=18
)

declare -Arg SCORES=(
    ['MAX']=13
    ['WIDTH']=30

    ['Y']=7
    ['X']=7
)

declare -Arg FIELD_OPTIONS=(
    ['SCORE,X']=28
    ['SCORE,Y']=6
    ['SCORE,WIDTH']=9

    ['LEVEL,X']=28
    ['LEVEL,Y']=11
    ['LEVEL,WIDTH']=9

    ['LINES,X']=28
    ['LINES,Y']=15
    ['LINES,WIDTH']=9

    ['ALERT,PAUSED']='P A U S E D'
    ['ALERT,SINGLE']='S I N G L E'
    ['ALERT,DOUBLE']='D O U B L E'
    ['ALERT,TRIPLE']='T R I P L E'
    ['ALERT,TETRIS']='T E T R I S'
    ['ALERT,GAME_OVER']='GAME   OVER'
    ['ALERT,END_REPLAY']='END  REPLAY'
    ['ALERT,CLEAR']='           '
    ['ALERT,X']=27
    ['ALERT,Y']=8
)

declare -Arg NEXT_PIECE=(
    ['R,X']=26  # Reset
    ['R,Y']=19

    ['I,X']=27
    ['I,Y']=19

    ['J,X']=28
    ['J,Y']=20

    ['L,X']=28
    ['L,Y']=20

    ['O,X']=29
    ['O,Y']=20

    ['S,X']=28
    ['S,Y']=20

    ['T,X']=28
    ['T,Y']=20

    ['Z,X']=28
    ['Z,Y']=20
)

################################ Tetrominoes ###################################

declare -rg BLANK='\u0020\u0020'
declare -rg GHOST='\u2592\u2592'
declare -rg BLOCK='\u2588\u2588'

setColours()
{
    case $_colourMode in
        'NORMAL')
            declare -ag COLOURS=(
                [0]=$'\e[0m'        # Default
                [1]=$'\e[38;5;43m'  # Cyan
                [2]=$'\e[38;5;27m'  # Blue
                [3]=$'\e[38;5;166m' # Orange
                [4]=$'\e[38;5;178m' # Yellow
                [5]=$'\e[38;5;76m'  # Green
                [6]=$'\e[38;5;128m' # Purple
                [7]=$'\e[38;5;160m' # Red
                [8]=$'\e[0;97m'     # White
            )
        ;;
        'SIMPLE')
            declare -ag COLOURS=(
                [0]=$'\e[0m'        # Default
                [1]=$'\e[38;5;27m'  # Blue
                [2]=$'\e[38;5;128m' # Purple
                [3]=$'\e[38;5;178m' # Yellow
                [4]=$'\e[38;5;76m'  # Green
                [5]=$'\e[38;5;43m'  # Cyan
                [6]=$'\e[38;5;205m' # Pink
                [7]=$'\e[38;5;160m' # Red
                [8]=$'\e[0;97m'     # White
            )
        ;;
        'SHADOW')
            declare -ag COLOURS=(
                [0]=$'\e[0;97m'   # white
                [1]=$'\e[0;97m'
                [2]=$'\e[0;97m'
                [3]=$'\e[0;97m'
                [4]=$'\e[0;97m'
                [5]=$'\e[0;97m'
                [6]=$'\e[0;97m'
                [7]=$'\e[0;97m'
                [8]=$'\e[0;97m'
            )
        ;;
        'BLEACH')
            declare -ag COLOURS=(
                [0]=$'\e[38;5;232;47m'   # Inverted white
                [1]=$'\e[38;5;232;47m'
                [2]=$'\e[38;5;232;47m'
                [3]=$'\e[38;5;232;47m'
                [4]=$'\e[38;5;232;47m'
                [5]=$'\e[38;5;232;47m'
                [6]=$'\e[38;5;232;47m'
                [7]=$'\e[38;5;232;47m'
                [8]=$'\e[38;5;232;47m'
            )
        ;;
    esac
}
setColours

declare -Arg COLOURS_LOOKUP=(
    [R]=0   # Reset
    [I]=1
    [J]=2
    [L]=3
    [O]=4
    [S]=5
    [T]=6
    [Z]=7
    [W]=8   # White
)

declare -arg PIECES=( 'I' 'J' 'L' 'O' 'S' 'T' 'Z' )

declare -arg I=(
    '0,1 1,1 2,1 3,1'
    '2,0 2,1 2,2 2,3'
    '0,2 1,2 2,2 3,2'
    '1,0 1,1 1,2 1,3'
)

declare -arg J=(
    '0,0 0,1 1,1 2,1'
    '1,0 2,0 1,1 1,2'
    '0,1 1,1 2,1 2,2'
    '1,0 1,1 0,2 1,2'
)

declare -arg L=(
    '2,0 0,1 1,1 2,1'
    '1,0 1,1 1,2 2,2'
    '0,1 1,1 2,1 0,2'
    '0,0 1,0 1,1 1,2'
)

declare -arg O=(
    '0,0 1,0 0,1 1,1'
    '0,0 1,0 0,1 1,1'
    '0,0 1,0 0,1 1,1'
    '0,0 1,0 0,1 1,1'
)

declare -arg S=(
    '1,0 2,0 0,1 1,1'
    '1,0 1,1 2,1 2,2'
    '1,1 2,1 0,2 1,2'
    '0,0 0,1 1,1 1,2'
)

declare -arg T=(
    '1,0 0,1 1,1 2,1'
    '1,0 0,1 1,1 1,2'
    '0,1 1,1 2,1 1,2'
    '1,0 1,1 2,1 1,2'
)

declare -arg Z=(
    '0,0 1,0 1,1 2,1'
    '2,0 1,1 2,1 1,2'
    '0,1 1,1 1,2 2,2'
    '1,0 0,1 1,1 0,2'
)

navigateMenu()
{
    local -n menu="$1"
    local -n menuOptions="${menu[OPTIONS]}"
    local                   \
        key1                \
        key2                \
        key3                \
        optionText          \
        selected=${2:-0}    \
        m

    while true; do
        for (( m = 0; $m < (${menu[MAX]} + 1); m++ )); do
            (( $m == $selected )) && optionText='\e[7m' || optionText='\e[27m'
            optionText+="${menu[PADDING]}${menuOptions[$m]}${menu[PADDING]}\e[27m"
            navigateTo ${menu[$m,Y]} ${menu[$m,X]}
            renderText "$optionText"
        done

        if test -n "${menu[$selected,NOTE]}"; then
            navigateTo ${NOTE[Y]} $(( ${NOTE[X]} - (${#menu[$selected,NOTE]} / 2) ))
            renderText "${menu[$selected,NOTE]}"
        fi

        IFS= read -srn 1 key1
        IFS= read -srn 1 -t 0.0001 key2
        IFS= read -srn 1 -t 0.0001 key3

        test -z "$key1" && break

        if test -n "${menu[$selected,NOTE]}"; then
            navigateTo ${NOTE[Y]} $(( ${NOTE[X]} - (${#NOTE[CLEAR]} / 2) ))
            renderText "${NOTE[CLEAR]}"
        fi

        case $key3 in
            $UP)    (( $selected == 0 ? selected = ${menu[MAX]} : selected-- ));;
            $DOWN)  (( $selected == ${menu[MAX]} ? selected = 0 : selected++ ));;
        esac
    done

    return $selected
}

clearSubMenu()
{
    local -n subClear="$1"
    local s

    for (( s = 0; $s < ${subClear[MAX]}; s++ )); do
        navigateTo $(( ${subClear[Y]} + $s )) ${subClear[X]}
        renderText "${subClear[$s]}"
    done
}

renderPartial()
{
    local -n partialOptions="$1"
    local           \
        c           \
        half        \
        optionText  \
        p

    for (( c = 0; $c < ${partialOptions[CLEAR,MAX]}; c++ )); do
        navigateTo $(( ${partialOptions[CLEAR,Y]} + $c )) ${partialOptions[CLEAR,X]}
        renderText "${partialOptions[CLEAR]}"
    done

    for (( p = 0; $p < (${partialOptions[MAX]} + 1); p++ )); do
        optionText="${!partialOptions[$p]}"
        half=$(( (${partialOptions[WIDTH]} - ${#optionText}) / 2 ))
        navigateTo ${partialOptions[$p,Y]} $(( ${partialOptions[$p,X]} + $half + 1 ))
        renderText "$optionText"
    done
}

renderMain()
{
    renderText "${MAIN_SCREEN[@]}"

    navigateMenu 'MAIN_MENU' ${_selected[main]}
    _selected['main']=$?
    case ${_selected[main]} in
        0)  setState 'FIELD';;      # New game
        1)  setState 'SCORES';;     # Scores
        2)  setState 'SETTINGS';;   # Settings
        3)  intrap;;
    esac
}

renderField()
{
    renderText "${FIELD_SCREEN[@]}"
}

renderScores()
{
    local                   \
        editableIndex       \
        editableRow         \
        line                \
        newScore=false      \
        playername          \
        score               \
        scores              \
        scoreShown=false    \
        userNames=()        \
        userScores=()

    (( $_score > 0 )) && newScore=true

    renderText "${SCORES_SCREEN[@]}"

    if $LEGACY; then
        IFS=$'\n' read -d '' -ra scores < "$HIGHSCORE_LOG"
    else
        readarray -t scores < "$HIGHSCORE_LOG"
    fi

    for (( line = 0; $line < ${#scores[@]}; line++ )); do
        userScores[$line]=${scores[$line]/*\,/}
        userNames[$line]=${scores[$line]/\,*/}

        if ! $scoreShown && $newScore && (( ${userScores[$line]} <= $_score )); then
            scoreShown=true
            editableIndex=$line
        fi
    done

    if $newScore; then
        test -z "$editableIndex" && editableIndex=${#scores[@]}
        # Insert current score into the arrays
        userNames=(
            ${userNames[@]:0:$editableIndex}
            ""
            ${userNames[@]:$editableIndex}
        )
        userScores=(
            ${userScores[@]:0:$editableIndex}
            $_score
            ${userScores[@]:$editableIndex}
        )
    fi

    for (( score = 0; $score < (${SCORES[MAX]} - 1); score++ )); do
        scoreRow=$(( ${SCORES[Y]} + $score ))
        if $newScore && (( $score == $editableIndex )); then
            editableRow=$scoreRow
        else
            printScore $scoreRow ${SCORES[X]} $(( $score + 1 )) "${userNames[$score]}" ${userScores[$score]}
        fi
    done

    if $newScore; then
        test -z "$editableRow" && editableRow=$(( ${SCORES[Y]} + ${SCORES[MAX]} ))

        printScore $editableRow ${SCORES[X]} $(( $editableIndex + 1 )) "" $_score true
        textEntry $editableRow $(( ${SCORES[X]} + 4 )) 8 "playername"

        # Add the new score to the highscores file
        if (( $editableIndex == ${#scores[@]} )); then
            printf '%s,%s\n' "$playername" "$_score" >> "$HIGHSCORE_LOG"
        else
            sed -i "$(( $editableIndex + 1 ))s/^/$playername\,$_score\n/" "$HIGHSCORE_LOG"
        fi

        _score=0
    fi

    navigateMenu 'SCORES_MENU'
    setState 'MAIN'
}

printScore()
{
    local                   \
        bit                 \
        bold=${6:-false}    \
        hrScore             \
        index=$3            \
        name="$4"           \
        pad                 \
        paddedScore         \
        score=$5            \
        spacer              \
        y=$1                \
        x=$2

    # Make the score human readable
    for (( bit = ${#score}; bit > 0; bit-- )); do
        (( $bit < ${#score} && $bit % 3 == 0 )) && hrScore+=","
        hrScore+="${score: -$bit:1}"
    done

    (( pad = ${SCORES[WIDTH]} - (4 + ${#name} + ${#hrScore}) ))
    eval printf -v spacer '%.0s.' {1..$pad}
    printf -v paddedScore '%-4s%s%s%s' "$index" "$name" "$spacer" "$hrScore"
    $bold && paddedScore="\e[1m$paddedScore"

    navigateTo $y $x
    renderText "$paddedScore"
}

textEntry()
{
    local               \
        inputString     \
        key             \
        maxLength=$3    \
        nameRef=$4      \
        y=$1            \
        x=$2

    navigateTo $y $x false

    # Turn echo back on for text input
    stty echo
    tput cvvis
    printf "\e[1m${COLOURS[${COLOURS_LOOKUP[R]}]}"
    clearBuffer

    # Clear IFS to avoid whitespace treated as null
    while IFS= read -sn1 key; do
        if [ -z "$key" ]; then
            if (( ${#inputString} )); then
                break
            else
                navigateTo $y $x false
            fi
        # If backspace character is pressed, remove last entry
        elif [[ "$key" == $'\177' ]]; then
            if (( ${#inputString} )); then
                printf '\b.\b'
                inputString=${inputString:0: -1}
            fi
        elif (( ${#inputString} > $maxLength )); then
            continue
        elif [[ "$key" == [\ _] ]]; then
            # Replace spaces with underscores
            printf '_'
            inputString+="_"
        elif [[ "$key" == [[:punct:]] ]]; then
            # Disallow punctuation
            continue
        elif [[ "$key" == [[:alnum:]] ]]; then
            printf "$key"
            inputString+="$key"
        fi
    done

    printf -v "$nameRef" '%s' "$inputString"
    printf "${COLOURS[${COLOURS_LOOKUP[R]}]}"
    tput civis
    stty -echo
}

saveSettings()
{
    if "$LEGACY"; then
        printf "%s='%s'\n" _colourMode $_colourMode
        printf "%s='%s'\n" _gameMode $_gameMode
        printf "%s='%s'\n" _ghosting $_ghosting
        printf "%s='%s'\n" _logging $_logging
        printf "%s='%s'\n" _ghostingIsSet $_ghostingIsSet
        printf "%s='%s'\n" _loggingIsSet $_loggingIsSet
    else
        printf '%s\n' ${_colourMode@A} ${_gameMode@A} ${_ghosting@A} ${_logging@A} ${_ghostingIsSet@A} ${_loggingIsSet@A}
    fi
}

renderSettings()
{
    renderText "${SETTINGS_SCREEN[@]}"

    renderPartial 'SETTINGS_SUB_MENU'
    navigateMenu 'SETTINGS_MENU' ${_selected[settings]}
    _selected['settings']=$?

    case ${_selected[settings]} in
        0|1)    clearSubMenu 'SETTINGS_CLEAR_SUB_MENU';;&
        0)      navigateMenu 'SETTINGS_COLOUR_SUB_MENU'
                setColourMode $?
                setColours;;
        1)      navigateMenu 'SETTINGS_GAME_SUB_MENU'
                setGameMode $?;;
        2)      toggleGhosting;;
        3)      toggleLogging;;
        4)      setState 'MAIN' # Return to main menu
                _selected['settings']=0;;
    esac

    saveSettings > "$SETTINGS"
}

renderScreen()
{
    case $_state in
        *)  clearScreen;;&
        0)  renderMain;;
        1)  renderField;;
        2)  renderScores;;
        3)  renderSettings;;
    esac
}

clearScreen()
{
    printf '\e[2J\e[1;1H'
}

clearBuffer()
{
    read -n10000 -t0.0001 # Clear input buffer
}

alert()
{
    local                   \
        key1                \
        sticky=${2:-false}  \
        unstick=${3:-''}

    navigateTo ${FIELD_OPTIONS[ALERT,Y]} ${FIELD_OPTIONS[ALERT,X]}
    renderText "\e[1m${FIELD_OPTIONS[ALERT,$1]}\e[0m"

    if $sticky; then
        while IFS= read -rsn1 key1; do
            IFS= read -rsn1 -t0.0001 key2
            if [[ "$key1" == $'\e' && "$key2" == '' ]] || \
                    [[ "$key1" == $unstick ]] || \
                    test -z "$key1" -a -z "$key2"; then
                alert 'CLEAR'
                break
            fi
        done
        clearBuffer
    fi

    if [[ "$1" == 'GAME_OVER' || "$1" == 'END_REPLAY' ]]; then
        sleep 2
    elif [[ "$1" != 'CLEAR' || "$1" != 'PAUSED' ]]; then
        printf -v _alertTimeout '%(%s)T' -1
        (( _alertTimeout += 2 ))
    fi
}

pause()
{
    alert 'PAUSED' true '[Pp]'
}

levelUp()
{
    local paddedText

    (( _level++ ))
    navigateTo ${FIELD_OPTIONS[LEVEL,Y]} ${FIELD_OPTIONS[LEVEL,X]}
    printf -v paddedText "%${FIELD_OPTIONS[LEVEL,WIDTH]}s" $_level
    renderText "$paddedText"
}

scoreUp()
{
    local           \
        modifier    \
        paddedText

    case $1 in
        1)  modifier=40;;
        2)  modifier=100;;
        3)  modifier=300;;
        4)  modifier=1200;;
    esac

    (( _score += $modifier * ($_level + 1) ))
    navigateTo ${FIELD_OPTIONS[SCORE,Y]} ${FIELD_OPTIONS[SCORE,X]}
    printf -v paddedText "%${FIELD_OPTIONS[SCORE,WIDTH]}s" $_score
    renderText "$paddedText"
}

lineUp()
{
    local           \
        l           \
        paddedText

    scoreUp $1
    for (( l = 0; l < $1; l++ )); do
        (( ++_lines % 10 == 0 )) && levelUp
    done

    case $1 in
        1)  alert 'SINGLE';;
        2)  alert 'DOUBLE';;
        3)  alert 'TRIPLE';;
        4)  alert 'TETRIS';;
    esac

    navigateTo ${FIELD_OPTIONS[LINES,Y]} ${FIELD_OPTIONS[LINES,X]}
    printf -v paddedText "%${FIELD_OPTIONS[LINES,WIDTH]}s" $_lines
    renderText "$paddedText"
}

destroyLines()
{
    local           \
        cleanPid    \
        colour      \
        offset=1    \
        tileType    \
        xPlus       \
        xPos        \
        yPlus       \
        yPos        \
        zeroes=0

    if ! [[ "$_colourMode" =~ (${COLOUR_MODES[2]}|${COLOUR_MODES[3]}) ]]; then
        for xPos in ${X_POSITIONS[@]}; do
            for yPos in $*; do
                navigateTo $yPos $xPos
                renderText "${COLOURS[${COLOURS_LOOKUP[W]}]}${BLOCK}${COLOURS[${COLOURS_LOOKUP[R]}]}"
            done
            sleep 0.02
        done
        sleep 0.04
    fi

    for xPos in ${X_POSITIONS[@]}; do
        for yPos in $*; do
            navigateTo $yPos $xPos
            renderText "${COLOURS[${COLOURS_LOOKUP[W]}]}${BLANK}${COLOURS[${COLOURS_LOOKUP[R]}]}"
            _lock[$yPos,$xPos]=0
        done
        sleep 0.02
    done

    for (( yPlus = ${@: -1} - 1; yPlus > 1; yPlus-- )); do
        if [[ " $* " =~ " $yPlus " ]]; then
            (( offset++ ))
            continue
        fi

        for xPlus in ${X_POSITIONS[@]}; do
            colour=${_lock[$yPlus,$xPlus]}
            if (( $colour )); then
                navigateTo $yPlus $xPlus
                renderText "${COLOURS[${COLOURS_LOOKUP[W]}]}${BLANK}${COLOURS[${COLOURS_LOOKUP[R]}]}"
                navigateTo $(( $yPlus + $offset )) $xPlus
                renderText "${COLOURS[$colour]}${BLOCK}${COLOURS[${COLOURS_LOOKUP[R]}]}"
                _lock[$yPlus,$xPlus]=0
            else
                (( zeroes++ ))
            fi
            _lock[$(( $yPlus + $offset )),$xPlus]=$colour
        done

        (( $zeroes == 10 )) && break || zeroes=0    # Blank line detected (no further lines above can have colour)
    done
}

checkLines()
{
    local               \
        line            \
        toDestroy=()    \
        xPos            \
        yPos

    for yPos in $*; do
        line=true
        for xPos in ${X_POSITIONS[@]}; do
            if ! (( ${_lock[$yPos,$xPos]} )); then
                line=false
                break
            fi
        done
        $line && toDestroy[$yPos]=
    done

    if (( ${#toDestroy[@]} )); then
        destroyLines ${!toDestroy[@]}
        lineUp ${#toDestroy[@]}
    fi
}

lockPiece()
{
    local -n piece="$1"
    local           \
        coord       \
        toCheck=()  \
        x=$3        \
        xAx         \
        y=$2        \
        yAx

    for coord in ${piece[$_rotation]}; do
        IFS=, read -r xAx yAx <<< $coord
        toCheck[(( $y + $yAx ))]= # Save as keys to avoid duplicates
        _lock[$(( $y + $yAx )),$(( $x + ($xAx * 2) ))]=${COLOURS_LOOKUP[$1]}
    done

    checkLines ${!toCheck[@]}
}

canRender()
{
    local -n piece="$1"
    local                   \
        coord               \
        x=$3                \
        xAx                 \
        y=$2                \
        yAx

    for coord in ${piece[$_rotation]}; do
        IFS=, read -r xAx yAx <<< $coord
        (( xAx = $x + ($xAx * 2) ))
        (( yAx = $y + $yAx ))

        # Needs to check tetromino collision first for rotation
        if (( ${_lock[$yAx,$xAx]} )); then
            return 4
        elif (( $xAx > $R_WALL )); then # Right wall
            return 1
        elif (( $xAx < $L_WALL )); then # Left wall
            return 3
        elif (( $yAx > $FLOOR )); then # Floor
            return 2
        fi
    done
}

renderPiece()
{
    local -n piece="$1"
    local                       \
        coord                   \
        tile                    \
        tileType=${4:-BLOCK}    \
        x=$3                    \
        xAx                     \
        y=$2                    \
        yAx

    tile="${COLOURS[${COLOURS_LOOKUP[$1]}]}${!tileType}${COLOURS[${COLOURS_LOOKUP[R]}]}"

    for coord in ${piece[$_rotation]}; do
        IFS=, read -r xAx yAx <<< $coord
        navigateTo $(( $y + $yAx )) $(( $x + ($xAx * 2) ))
        renderText "$tile"
    done
}

renderGhost()
{
    renderPiece "$1" $2 $3 'GHOST'
}

removePiece()
{
    renderPiece "$1" $2 $3 'BLANK'
}

renderNextPiece()
{
    removePiece "$_currentPiece" ${NEXT_PIECE[$_currentPiece,Y]} ${NEXT_PIECE[$_currentPiece,X]}
    renderPiece "$_nextPiece" ${NEXT_PIECE[$_nextPiece,Y]} ${NEXT_PIECE[$_nextPiece,X]}
}

navigateTo()
{
    printf '\e[%s;%sH' $1 $2
}

renderText()
{
    (( $# > 1 )) && printf "${COLOURS[0]}%b\e[0m\n" "${@:1:$#-1}"
    printf "${COLOURS[0]}%b\e[0m" "${@: -1}"
}

movePiece()
{
    local               \
        nextX=$_pieceX  \
        nextY=$_pieceY

    case $direction in
        $DOWN)  timeTaken=0 # Reset timer
                (( nextY++ ));;
        $RIGHT) (( nextX += 2 ));;
        $LEFT)  (( nextX -= 2 ));;
    esac

    canRender "$_currentPiece" $nextY $nextX

    if (( $? == 0 )); then
        removePiece "$_currentPiece" $_pieceY $_pieceX
        [[ "$direction" != "$DOWN" ]] && $_ghostingIsSet && removePiece "$_currentPiece" $_ghostY $_pieceX

        _pieceX=$nextX
        _pieceY=$nextY

        [[ "$direction" != "$DOWN" ]] && $_ghostingIsSet && ghostPiece
        renderPiece "$_currentPiece" $_pieceY $_pieceX
    elif [[ "$direction" == "$DOWN" ]]; then
        lockPiece "$_currentPiece" $_pieceY $_pieceX
        newPiece=true
    fi

    $_loggingIsSet && logInput 'TRANSLATE'
}

rotatePiece()
{
    if [[ "$_gameMode" == 'ROTATE' ]]; then
        (( $_rotation == 3 )) && return
    fi

    local                           \
        captureRotation=$_rotation  \
        posX=$_pieceX               \
        posY=$_pieceY

    removePiece "$_currentPiece" $_pieceY $_pieceX
    $_ghostingIsSet && removePiece "$_currentPiece" $_ghostY $_pieceX

    (( _rotation == 3 ? _rotation = 0 : _rotation++ ))

    while true; do
        canRender "$_currentPiece" $posY $posX

        case $? in
            0)      break;;
            1)      (( posX -= 2 ));; # Right wall
            3)      (( posX += 2 ));; # Left wall
            2|4)    _rotation=$captureRotation
                    renderPiece "$_currentPiece" $_pieceY $_pieceX
                    return;; # Floor or another tetromino
        esac
    done

    _pieceX=$posX
    _pieceY=$posY

    $_ghostingIsSet && ghostPiece
    renderPiece "$_currentPiece" $_pieceY $_pieceX
    $_loggingIsSet && logInput 'ROTATE'
}

dropPiece()
{
    local nextY=$_pieceY

    removePiece "$_currentPiece" $_pieceY $_pieceX

    while canRender "$_currentPiece" $(( ++nextY )) $_pieceX; do
        _pieceY=$nextY
    done

    renderPiece "$_currentPiece" $_pieceY $_pieceX
    lockPiece "$_currentPiece" $_pieceY $_pieceX
    newPiece=true
    $_loggingIsSet && logInput 'TRANSLATE'
}

ghostPiece()
{
    local               \
        firstLoop=true  \
        nextY=$_pieceY

    _ghostY=$nextY
    while canRender "$_currentPiece" $(( ++nextY )) $_pieceX; do
        firstLoop=false
        _ghostY=$nextY
    done
    $firstLoop && return

    renderGhost "$_currentPiece" $_ghostY $_pieceX
}

setDefaults()
{
    if $_replay; then
        _currentPiece=${_replayInputs[$(( _replayIndex++ ))]}
    else
        test -n "$_nextPiece" && _currentPiece=$_nextPiece || _currentPiece=${PIECES[$(( $RANDOM % ${#PIECES[@]} ))]}
        _nextPiece=${PIECES[$(( $RANDOM % ${#PIECES[@]} ))]}
    fi

    # Starting geometry for new pieces
    _rotation=0
    IFS=',' read _pieceY _pieceX <<< $START_POSITION
    newPiece=false
    $_loggingIsSet && logInput 'PIECE'
}

logInput()
{
    case "$1" in
        'PIECE')        printf '%s' $_currentPiece;;
        'TRANSLATE')    printf '%s' $direction;;
        'ROTATE')       printf '%s' 'R';;
    esac >> "$INPUT_LOG"
}

replayGameLoop()
{
    local                       \
        direction               \
        updatePosition=false    \
        newPiece=true           \
        unixTime

    while true; do
        if test -z "${_replayInputs[$_replayIndex]}"; then
            alert 'END_REPLAY'
            exit 0
        fi
        if $newPiece; then
            setDefaults
            canRender "$_currentPiece" $_pieceY $_pieceX
            (( $? )) && continue

            renderPiece "$_currentPiece" $_pieceY $_pieceX
            $_ghostingIsSet && ghostPiece
            clearBuffer
        elif $updatePosition; then
            movePiece
            updatePosition=false
            $newPiece && continue
        fi

        case ${_replayInputs[$(( _replayIndex++ ))]} in
            'R')    rotatePiece;;
            $UP)    direction=$UP
                    dropPiece;;
            $DOWN)  direction=$DOWN
                    updatePosition=true;;
            $RIGHT) direction=$RIGHT
                    updatePosition=true;;
            $LEFT)  direction=$LEFT
                    updatePosition=true;;
        esac

        printf -v unixTime '%(%s)T' -1
        (( $_alertTimeout && $unixTime >= $_alertTimeout )) && alert 'CLEAR'

        sleep 0.001
    done
}

gameLoop()
{
    local                       \
        direction               \
        key1                    \
        key2                    \
        key3                    \
        updatePosition=false    \
        newPiece=true           \
        postTime                \
        preTime                 \
        readStatus=0            \
        speed                   \
        tick                    \
        timeTaken=0             \
        unixTime

    while true; do
        if $newPiece; then
            setDefaults
            canRender "$_currentPiece" $_pieceY $_pieceX
            if (( $? )); then
                renderPiece "$_currentPiece" $_pieceY $_pieceX
                alert 'GAME_OVER'
                setState 'SCORES'
                return
            fi

            renderPiece "$_currentPiece" $_pieceY $_pieceX
            $_ghostingIsSet && ghostPiece
            renderNextPiece
            clearBuffer
        elif $updatePosition; then
            movePiece
            updatePosition=false
            $newPiece && continue
        fi

        preTime=$( date '+%2N' )
        preTime=${preTime#0}

        # Lower numer means faster speed
        (( speed = 90 - $_level * 4 ))
        (( $speed < 20 )) && speed=20

        (( tick = $speed - $timeTaken ))
        (( $tick < 0 )) && tick=0
        (( $tick < 10 )) && tick="0$tick"

        # Read STDIN with the timeout relative to the speed
        IFS= read -rsn1 -t0.$tick key1
        readStatus=$?
        IFS= read -rsn1 -t0.0001 key2
        IFS= read -rsn1 -t0.0001 key3

        # If read timeout was interrupted
        if (( $readStatus != 142 )); then
            # If enter or space is pressed
            if test -z "$key1" || [[ "$key1" == " " ]]; then
                rotatePiece
                sleep 0.05
            elif [[ "$key1" == [Pp] ]] && test -z "$key2" -a -z "$key3"; then
                pause
            # If escape character is pressed
            elif [[ "$key1" == $'\e' ]] && test -n "$key2"; then
                case $key3 in
                    $UP)    direction=$UP
                            dropPiece;;
                    $DOWN)  direction=$DOWN
                            updatePosition=true;;
                    $RIGHT) direction=$RIGHT
                            updatePosition=true;;
                    $LEFT)  direction=$LEFT
                            updatePosition=true;;
                esac
            fi
        fi

        postTime=$( date '+%2N' )
        postTime=${postTime#0}

        (( $postTime < $preTime )) && (( postTime += 100 ))
        if (( $timeTaken )); then
            (( timeTaken += $postTime - $preTime ))
        else
            (( timeTaken = $postTime - $preTime ))
        fi

        if (( $timeTaken >= $speed )); then
            updatePosition=true
            direction=$DOWN
            timeTaken=0

            printf -v unixTime '%(%s)T' -1
            (( $_alertTimeout && $unixTime >= $_alertTimeout )) && alert 'CLEAR'
        fi

        unset key1 key2 key3
    done
}

# Set BLANK global variables to allow restarting
newGame()
{
    _level=0
    _lines=0

    # Collision detection
    unset _lock
    declare -Ag _lock[{2..23},{2..20..2}]=${COLOURS_LOOKUP[R]}

    # Truncate input log file
    $_loggingIsSet && : > "$INPUT_LOG"

    # scoreModifier false
    $_replay && replayGameLoop || gameLoop
    return $?
}

while true; do
    case $_state in
        *)  renderScreen;;&
        1)  newGame;;
    esac
done
